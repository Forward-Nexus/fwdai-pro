/**
 * FWD PRO Update System
 * 
 * Handles updating existing FWD PRO installations
 */

import fs from 'fs-extra';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { 
  hasInstallation, 
  getInstalledVersion, 
  getPackageVersion,
  runMigrations 
} from './migrations.js';
import { createFavorites } from './favorites.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const FWD_PRO_SOURCE = path.join(__dirname, '..', '..', 'pro-os');

/**
 * Main update function
 */
export async function updateInstallation() {
  const projectPath = process.cwd();

  console.clear();
  console.log(
    chalk.bold.cyan('\nüîÑ FWD PRO Update System\n')
  );

  // Check if installation exists
  if (!await hasInstallation(projectPath)) {
    console.log(chalk.red('‚ùå No FWD PRO installation found in this directory.'));
    console.log(chalk.gray('\nRun: npx @fwd-ai/pro install\n'));
    process.exit(1);
  }

  try {
    const installedVersion = await getInstalledVersion(projectPath);
    const packageVersion = await getPackageVersion();

    console.log(chalk.gray(`Currently installed: v${installedVersion}`));
    console.log(chalk.gray(`Package version: v${packageVersion}\n`));

    // Check if update is needed
    if (installedVersion === packageVersion) {
      console.log(chalk.green('‚úì Already up to date!\n'));
      return;
    }

    console.log(chalk.yellow(`‚ö†Ô∏è  Update available: v${installedVersion} ‚Üí v${packageVersion}\n`));

    // Step 1: Backup user data
    let spinner = ora('Backing up your data...').start();
    
    const fwdproDir = path.join(projectPath, '.fwdpro');
    const backupDir = path.join(projectPath, '.fwdpro-backup');
    
    await fs.ensureDir(backupDir);
    
    // Backup critical user data
    const backupPaths = [
      'documents',
      '0-roundtable/workspace',
      'pro-os/project/config.yaml',
      'pro-os/project/project-kb.md',
      'pro-os/project/mission.md',
      'pro-os/project/people.md',
      'pro-os/project/founder-profile.md'
    ];

    for (const backupPath of backupPaths) {
      const sourcePath = path.join(fwdproDir, backupPath);
      if (await fs.pathExists(sourcePath)) {
        const targetPath = path.join(backupDir, backupPath);
        await fs.copy(sourcePath, targetPath);
      }
    }

    spinner.succeed(chalk.green('‚úì Data backed up'));

    // Step 2: Backup experts with customizations
    spinner = ora('Backing up expert customizations...').start();
    
    const expertsBackupDir = path.join(backupDir, 'experts-backup');
    const expertsDir = path.join(fwdproDir, 'pro-os', 'experts');
    
    if (await fs.pathExists(expertsDir)) {
      await fs.copy(expertsDir, expertsBackupDir);
    }
    
    spinner.succeed(chalk.green('‚úì Expert customizations backed up'));

    // Step 3: Nuclear update - delete and replace system folders
    spinner = ora('Updating system files...').start();

    // Delete entire system folders (nuclear approach - ensures no stale files)
    const systemFoldersToNuke = [
      'pro-os/commands',
      'pro-os/experts',
      'pro-os/system',
      'pro-os/user-docs',
      'pro-os/templates',  // This too in case it exists
      '0-your-commands',   // Regenerated by favorites
      '0-your-experts'     // Regenerated by favorites
    ];

    for (const folder of systemFoldersToNuke) {
      const targetPath = path.join(fwdproDir, folder);
      if (await fs.pathExists(targetPath)) {
        await fs.remove(targetPath);
      }
    }

    // Copy fresh system files from package
    const updatePaths = [
      'pro-os/commands',
      'pro-os/experts',
      'pro-os/system',
      'pro-os/user-docs'
    ];

    for (const updatePath of updatePaths) {
      const sourcePath = path.join(FWD_PRO_SOURCE, updatePath.replace('pro-os/', ''));
      const targetPath = path.join(fwdproDir, updatePath);
      
      if (await fs.pathExists(sourcePath)) {
        await fs.copy(sourcePath, targetPath);
      }
    }

    spinner.succeed(chalk.green('‚úì System files updated'));

    // Step 3.5: Three-way merge for expert files
    spinner = ora('Merging expert customizations...').start();
    
    const conflictedExperts = [];
    
    if (await fs.pathExists(expertsBackupDir)) {
      const expertFiles = await fs.readdir(expertsBackupDir);
      
      for (const expertFile of expertFiles) {
        if (!expertFile.endsWith('.md')) continue;
        
        const userOldPath = path.join(expertsBackupDir, expertFile);
        const newPath = path.join(fwdproDir, 'pro-os', 'experts', expertFile);
        
        // Skip if new expert file doesn't exist (might be removed expert)
        if (!await fs.pathExists(newPath)) continue;
        
        try {
          // Read files
          const userOldContent = await fs.readFile(userOldPath, 'utf8');
          const newContent = await fs.readFile(newPath, 'utf8');
          
          // Always merge Project Context section (safest)
          const projectContextRegex = /## Project Context[^]*$/m;
          const userProjectContext = userOldContent.match(projectContextRegex)?.[0];
          
          let finalContent = newContent;
          if (userProjectContext) {
            finalContent = newContent.replace(projectContextRegex, userProjectContext);
          }
          
          // Detect if user customized OTHER parts (not just Project Context)
          const beforeContextRegex = /^[\s\S]*?(?=## Project Context)/m;
          const userBefore = userOldContent.match(beforeContextRegex)?.[0] || userOldContent;
          const newBefore = newContent.match(beforeContextRegex)?.[0] || newContent;
          
          // Normalize for comparison
          const userNormalized = userBefore.replace(/\s+/g, ' ').trim();
          const newNormalized = newBefore.replace(/\s+/g, ' ').trim();
          
          if (userNormalized !== newNormalized) {
            // User customized! Create merge conflict file
            conflictedExperts.push(expertFile);
            
            // Split into sections for better merge
            const sections = [
              { name: 'YAML Front Matter', regex: /^---[\s\S]*?---/m },
              { name: 'Core Content', regex: /^---[\s\S]*?---[\s\S]*?(?=## Project Context)/m },
              { name: 'Project Context', regex: /## Project Context[^]*$/m }
            ];
            
            let mergedWithConflicts = '';
            
            for (const section of sections) {
              const userSection = userOldContent.match(section.regex)?.[0] || '';
              const newSection = newContent.match(section.regex)?.[0] || '';
              
              if (section.name === 'Project Context') {
                // Always use user's Project Context
                mergedWithConflicts += userSection || newSection;
              } else if (userSection === newSection || section.name === 'YAML Front Matter') {
                // Same or front matter - use new version
                mergedWithConflicts += newSection;
              } else {
                // Different! Create conflict markers
                mergedWithConflicts += `\n<<<<<<< YOUR CUSTOMIZATIONS (from v${installedVersion})\n`;
                mergedWithConflicts += userSection;
                mergedWithConflicts += `\n=======\n`;
                mergedWithConflicts += newSection;
                mergedWithConflicts += `\n>>>>>>> FWD PRO UPDATE (v${packageVersion})\n`;
              }
            }
            
            // Write conflict file
            const conflictPath = path.join(fwdproDir, 'pro-os', 'experts', expertFile);
            await fs.writeFile(conflictPath, mergedWithConflicts);
            
            // Also save clean copies for reference
            const backupDir = path.join(projectPath, '.fwdpro-merge-conflicts');
            await fs.ensureDir(backupDir);
            await fs.writeFile(
              path.join(backupDir, `${expertFile}.YOUR_VERSION`),
              userOldContent
            );
            await fs.writeFile(
              path.join(backupDir, `${expertFile}.NEW_VERSION`),
              newContent
            );
            
          } else {
            // No customizations, just use new version with user's Project Context
            await fs.writeFile(newPath, finalContent);
          }
          
        } catch (error) {
          console.log(chalk.yellow(`‚ö†Ô∏è  Could not merge ${expertFile}: ${error.message}`));
        }
      }
    }
    
    spinner.succeed(chalk.green('‚úì Expert files merged'));

    // Step 4: Clean up project-level artifacts
    spinner = ora('Cleaning up old artifacts...').start();
    
    // Remove .cursor/ folder (removed in 2.0.1)
    const cursorPath = path.join(projectPath, '.cursor');
    if (await fs.pathExists(cursorPath)) {
      await fs.remove(cursorPath);
    }
    
    spinner.succeed(chalk.green('‚úì Old artifacts removed'));

    // Step 5: Run version-specific migrations
    await runMigrations(projectPath, installedVersion, packageVersion);

    // Step 6: Restore user data
    spinner = ora('Restoring your data...').start();

    for (const backupPath of backupPaths) {
      const sourcePath = path.join(backupDir, backupPath);
      if (await fs.pathExists(sourcePath)) {
        const targetPath = path.join(fwdproDir, backupPath);
        await fs.copy(sourcePath, targetPath, { overwrite: true });
      }
    }

    spinner.succeed(chalk.green('‚úì Data restored'));

    // Step 7: Regenerate favorites (shortcuts)
    spinner = ora('Regenerating command/expert shortcuts...').start();
    
    // Load config to get work types for favorites
    const configPath = path.join(fwdproDir, 'pro-os', 'project', 'config.yaml');
    let workTypes = [];
    if (await fs.pathExists(configPath)) {
      const yaml = await import('js-yaml');
      const configContent = await fs.readFile(configPath, 'utf8');
      const config = yaml.load(configContent);
      workTypes = config?.founder?.workTypes || [];
    }
    
    await createFavorites(projectPath, workTypes);
    spinner.succeed(chalk.green('‚úì Shortcuts regenerated'));

    // Step 8: Update version file
    spinner = ora('Updating version...').start();
    
    await fs.writeFile(
      path.join(fwdproDir, 'pro-os', 'system', '.version'),
      packageVersion
    );
    
    // Remove old version file if it exists (migration from 1.1.1)
    const oldVersionFile = path.join(fwdproDir, '.version');
    if (await fs.pathExists(oldVersionFile)) {
      await fs.remove(oldVersionFile);
    }

    spinner.succeed(chalk.green('‚úì Version updated'));

    // Step 9: Clean up backup
    spinner = ora('Cleaning up...').start();
    await fs.remove(backupDir);
    spinner.succeed(chalk.green('‚úì Cleanup complete'));

    // Success message
    console.log(
      chalk.bold.green(`\n‚úÖ Successfully updated to v${packageVersion}!\n`)
    );

    console.log(chalk.gray('Your documents, workspace, and configuration have been preserved.'));
    console.log(chalk.gray('System files (commands, experts, standards) have been updated.\n'));
    
    // If merge conflicts were detected, show resolution instructions
    if (conflictedExperts.length > 0) {
      console.log(chalk.bold.yellow('‚ö†Ô∏è  MERGE CONFLICTS DETECTED\n'));
      console.log(chalk.yellow('The following expert files have been customized and need manual merge:'));
      
      for (const expertFile of conflictedExperts) {
        console.log(chalk.yellow(`  - ${expertFile}`));
      }
      
      console.log(chalk.gray('\nThese files now contain Git-style merge conflict markers like:\n'));
      console.log(chalk.cyan('  <<<<<<< YOUR CUSTOMIZATIONS (from v' + installedVersion + ')'));
      console.log(chalk.gray('  [your custom content]'));
      console.log(chalk.cyan('  ======='));
      console.log(chalk.gray('  [new FWD PRO content with improvements]'));
      console.log(chalk.cyan('  >>>>>>> FWD PRO UPDATE (v' + packageVersion + ')\n'));
      
      console.log(chalk.bold.cyan('How to Resolve:\n'));
      console.log(chalk.gray('1. Open the expert file: .fwdpro/pro-os/experts/[expert-name].md'));
      console.log(chalk.gray('2. Search for "<<<<<<" to find conflicts'));
      console.log(chalk.gray('3. Choose which version to keep (or merge both manually)'));
      console.log(chalk.gray('4. Delete the conflict markers (<<<<<<, =======, >>>>>>>)'));
      console.log(chalk.gray('5. Save the file\n'));
      
      console.log(chalk.gray('Clean copies available for reference in: .fwdpro-merge-conflicts/'));
      console.log(chalk.gray('  - [expert].YOUR_VERSION = your old customized version'));
      console.log(chalk.gray('  - [expert].NEW_VERSION = new FWD PRO version\n'));
      
      console.log(chalk.yellow('‚ö†Ô∏è  Your AI experts may not work correctly until conflicts are resolved!\n'));
    }

  } catch (error) {
    console.error(
      chalk.bold.red('\n‚ùå Update failed\n')
    );
    console.error(chalk.red(error.message));
    console.error(chalk.yellow('\nYour data is safe in .fwdpro-backup/'));
    console.error(chalk.gray('Please report this issue: https://github.com/Forward-Nexus/fwdai-pro/issues\n'));
    process.exit(1);
  }
}

